---
title: "KMA712 Assignment 2"
author: "Bindoff, A."
output: html_document
---

`r Sys.time()`

3 week Extension granted (email correspondence 12th June 2019)  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r}
# Example data
library(microbiome)
library(dplyr)
library(table1)
library(captioner)

data(dietswap)

# assure namespace issue is fixed
transform <- microbiome::transform

#devtools::install_github("hrbrmstr/hrbrthemes")
library(hrbrthemes)
library(gcookbook)
library(tidyverse)
library(phyloseq)


shuffle <- function(x, set.seed = 42){
  set.seed(set.seed)
  sample(x, length(x), replace = FALSE)
}

#pal <- shuffle(scico::scico(n = 17, palette ='berlin'), set.seed = 99)
pal <- shuffle(c(scico::scico(n = 11, palette ='berlin'),
         scico::scico(n = 11, palette ='hawaii')), set.seed = 99)

```

## Background {.tabset}

Colon cancer is a leading cause of cancer death in North America and Europe. Despite advances in early detection widely available in North America, African Americans (AAM) have a far higher incidence of death by colon cancer (65:100,000) than rural Africans (AFR), at <5:100,000 [@o2015fat]. Although colon cancer risk is determined by many factors, diet may explain some of the differences between AAM and AFR.  

In order to investigate differences in gut microbiota potentially caused by diet between AAM and AFR, O'Keefe and colleagues collected stool samples before and after a dietary intervention in age and sex matched samples of healthy AAM and AFR participants [@o2015fat]. A HITChip phylogenetic microarray was used to profile microbiota composition.  

For this reproducible workflow we obtained data from the O'Keefe study, which was included in the `microbiome` R package [@lahti2019]. Data were prepared loosely following the tutorial [Introduction to the microbiome R package](http://microbiome.github.io/microbiome/Composition.html), filtering on pre-intervention and taking the first sample collected within each group in order to avoid pseudo-replication considerations. We also filtered on the most prevalent taxa to reduce the data in order to aid interpretation and reduce computation time.  

```{r echo = TRUE}
# Use most prevalent taxa to speed up examples
# detection threshold >50 otus, prevalence > .4
pseq <- core(dietswap, detection = 50, prevalence = .4)

# choose sample subset, first sample collection pre-intervention
pseq2 <- subset_samples(pseq, group == "HE" & timepoint.within.group == 1)

# normative western adults for comparison
data(atlas1006)
pseq3 <- atlas1006 %>%
          subset_samples(DNA_extraction_method == "r") %>%
          aggregate_taxa(level = "Phylum") %>%  
          microbiome::transform(transform = "compositional")

```

```{r}
# working with phyloseq objects is not difficult but 
# for some tasks without `phyloseq` or `microbiome` methods
# a data.frame or tibble can be helpful for a novice like me

otu <- tibble::rownames_to_column(as.data.frame(t(otu_table(pseq2)))) %>%
  mutate(sample = rowname) %>%
  select(-rowname)

d <- as_tibble(sample_data(pseq2)) %>% 
  left_join(otu)

label(d$sex) <- "Gender"
label(d$bmi_group) <- "BMI category"

table_nums <- captioner::captioner(prefix = "Table")
tab.1 <- table_nums(name = "tab_1",
                    caption = "Demographics, African American (AAM) and rural African (AFR) participants")
fig_nums <- captioner::captioner(prefix = "Figure")
fig.1 <- fig_nums(name = "fig_1",
                  caption = "Abundance of each taxa, sorted by bacteroidetes")

fig.2 <- fig_nums(name = "fig_2",
                  caption = "Abundance of genera in each sample, sorted by study groups")

fig.3 <- fig_nums(name = "fig_3",
                  caption = "Average abundance of genera for each BMI group")

```

`r table_nums('tab_1')`

```{r table_1, fig.cap = tab.1}

table1(~ sex +  bmi_group | nationality, d)

```
  
  
`r fig_nums('fig_1')`


```{r fig_1, fig.cap = fig.1}
theme_set(theme_bw(21))
p <- pseq3 %>%
    plot_composition(sample.sort = "Bacteroidetes", otu.sort = "abundance", alpha = 0.3) +
         # Set custom colors
          scale_fill_manual(values = default_colors("Phylum")[taxa(pseq3)]) +
  facet_wrap(~Tax, scales = "free_y") +
  theme(text = element_text(size = 8),
    axis.text.x = element_blank())


print(p)

```

Relative abundance of core taxa sorted by study group (AAM and AFR) shows differential abundance of genera. Note relative abundance of *Prevotella melaninogenica* (shaded in pink), which is more abundant in the AFR group.  

`r fig_nums('fig_2')`

```{r genera, fig.cap = fig.2}

# Limit the analysis on core taxa and specific sample group
p <- plot_composition(pseq2,
              taxonomic.level = "Genus",
                      sample.sort = "nationality",
                      x.label = "nationality") +
     guides(fill = guide_legend(ncol = 1)) +
   scale_fill_manual(values = pal, name = "Genera") +
     scale_y_percent() +
     labs(x = "Samples", y = "Relative abundance (%)",
                                   title = "Relative abundance data",
                                   subtitle = "",
                                   caption = "") + 
    # theme_ipsum(grid="Y") +
  theme(text = element_text(size = 8),
    axis.text.x = element_text(size = 6, angle = 90),
        legend.key.height = unit(2, "mm"))
print(p)  
```

Averaging abundance by BMI group shows a greater abundance of *Prevotella melaninogenica* in lean participants, but Table 1 shows more lean rural Africans than African Americans so this pattern must be interpreted with caution.  

`r fig_nums('fig_3')`  

```{r bmi_group, fig.cap = fig.3}

# Averaged by group
p <- plot_composition(pseq2,
                      average_by = "bmi_group", transform = "compositional") +
  scale_fill_manual(values = pal) +
  theme(text = element_text(size = 10),
        legend.key.height = unit(4, "mm"))
print(p)
```

*Ordination* reduces high-dimension data to lower-dimensional data, such that objects that are similar to each other are projected onto a lower-dimensional space 'nearer' to each other and objects that are dissimilar are projected further apart. 

We compute a distance matrix of genera based on sample similarities then reduce these distances to a two-dimensional space using t-distributed stochastic neighbour embeddings (tSNE). Taxa that appear in similar compositions in samples should be nearer to each other than taxa that are dissimilar.  

```{r}
library(Rtsne)
library(vegan)
set.seed(42)

# distance matrix (sample similarities)
ps <- microbiome::transform(pseq2, "hellinger")
dm <- vegdist(otu_table(ps), "euclidean")

m1 <- Rtsne(dm, dims = 2, perplexity = 7, theta = 0.1, max_iter = 5000, verbose = F)

proj <- m1$Y
rownames(proj) <- rownames(otu_table(ps))
proj <- tibble::rownames_to_column(as.data.frame(proj)) # so we can use rownames as labels

ggplot(proj, aes(x = V1, y = V2, label = rowname)) +
  geom_text(nudge_y = -1.5, size = 2.5) +
  geom_point()
```

Using a similar approach, we ordinate samples on two dimensions using tSNE. This could be considered an *unsupervised statistical learning* method, because tSNE doesn't know about nationality, BMI etc, only (standardized) abundance of taxa in each sample. In fig______ we plot the ordination using symbols for nationality and shade with a genera of interest.  

```{r}
A <- apply(d[, c(9:25)], 2, function(x) scale(log(x)))  # standardize across taxa


set.seed(42)
m2 <- Rtsne(A, dims = 2, perplexity = 9, theta = .05, max_iter = 5000, verbose = F)

# put results in data.frame for plotting
B1 <- data.frame(d,
                 m2$Y)

ggplot(B1, aes(x = X1, y = X2,
               shape = nationality,
               colour = `Prevotella.melaninogenica.et.rel.`)) +
  geom_point(size = 3) +
  scico::scale_colour_scico(palette = "vik") +
  theme_minimal()
```

This realisation of the data clearly shows two clusters, one composed entirely of samples from African-Americans with low abundance of *Prevotela melaninogenica* and the other composed mostly of rural Africans with high abundance of *Prevotela melaninogenica*. I say *"this realisation of the data"*, because tSNE is a stochastic algorithm and a different throw of the dice, with different parameters, can produce different low-dimensional representations of the data. The risk here is that users may choose a low-dimensional representation that supports their pre-conceived ideas (in this case, there are implied hypotheses about nationality and *Prevotela melaninogenica* that the figure appears to support). Some [hyper-]parameter sensitivity analysis is prudent.  

Parameters to tune include learning rate, max iterations, and perplexity (which we will describe in the following paragraph). Learning rate (*theta* in the `Rtsne` package) makes a trade-off between speed and accuracy, with *theta* = 0 being 'pure' tSNE (in the above example *theta* = 0.05) and *theta* in (0, 1] being an approximation. The number of iterations can be assessed by confirming that the algorithm has converged (i.e that the clusters represented in low-dimensional space are stable when the number of iterations is increased by some non-trivial amount).

An additional hyper-parameter, somewhat unique to tSNE, is *perplexity* which aims to balance representation of global and local relationships in the data. Figure ___ shows robustness to choice of perplexity. It is important to note that tSNE aims to preserve distance relationships between objects, such that objects that are similar cluster together in low-dimensional space and objects that are different are further apart. It does not preserve Euclidean distances in high-dimensional space, and thus the scales are meaningless (which is clear in the animation).  

```{r}
set.seed(42)

perplexity_iter <- function(x, p){
  Rtsne(x, dims = 2, perplexity = p, max_iter = 2000, theta = 0.05, verbose = FALSE)
}
# make a list of tSNE fits with varying perplexity
m <- lapply(c(4, 7, 9, 12), function(p) perplexity_iter(x = A, p = p))

extract_ys <- function(m){
  perplexity <- m$perplexity
  Y1 <- m$Y[,1]
  Y2 <- m$Y[,2]
  cbind(d, Y1, Y2, perplexity)
}

# put all the fits in a data frame for the animation
k <- bind_rows(lapply(m, extract_ys))

```

```{r}
# animate to show effect of varying perplexity (similarity preserved, absolute scale not informative)
library(gganimate)
ggplot(k, aes(x = Y1, y = Y2, shape = nationality, colour = `Prevotella melaninogenica et rel.`)) +
  geom_point(size = 4) +
  scico::scale_colour_scico(palette = "vik") +
  theme_minimal() +
  transition_states(perplexity) +
  ease_aes('linear') +
  view_follow() +
  labs(title = 'Perplexity = {closest_state}')

```

How does tSNE achieve this? Stochastic Neighbour Embedding (SNE) defines the similarity of datapoints $x_i$ and $x_j$ as the conditional probability, $p_{j|i}$, that $x_i$ would 'choose' $x_j$ as its neighbour if neighbour choices were made in proportion to their probability density under a Gaussian centered at $x_i$ in high-dimensional space. A similar conditional probability, $q_{j|i}$ is computed for low-dimensional counter-parts, $y_i$ and $y_j$. Using gradient descent, SNE minimises the sum of Kullback-Leibler divergences,
$$\sum_i \sum_j p_{j|i}log \frac {p_{j|i}}{q_{j|i}} $$

Shading datapoints by genera abundance gives a sense of the low-dimensional spatial relationships between them.  

```{r}

# make a data frame that colours points one column/genera at a time
foo <- function(x){
  d %>% mutate(col = scale(unlist(d[, x]), center = FALSE),
               shade = x,
                    Y1 = m2$Y[, 1],
                    Y2 = m2$Y[, 2])
  
}

k <- lapply(names(d[, 9:25]), foo)
k <- dplyr::bind_rows(k)

ggplot(k, aes(x = Y1, y = Y2, shape = nationality, colour = col)) +
  geom_point(size = 5) +
  scico::scale_colour_scico(palette = "vik") +
  theme_minimal() +
  transition_states(shade) +
  ease_aes('sine-in-out') +
  labs(title = 'Taxa shading = {closest_state}')

```

```{r}
set.seed(42)

# sort genera using Classical Multidimensional Scaling
D <- dist(A, method = "euclidean")
m3 <- cmdscale(D, k = 1)

# sort samples using Classical Multidimensional Scaling
m4 <- cmdscale(dm, k = 1)
proj <- m4[,1]
proj <- tibble::rownames_to_column(as.data.frame(proj)) %>% arrange(proj)




# arrange samples and taxa by ordination above
B1 <- data.frame(d,
                 m3.Y = m3[,1]) %>%
  arrange(m3.Y) %>%  # arrange samples by ordination provided in m3.Y
  mutate(sample = factor(sample, sample)) %>%
  reshape2::melt(id.vars = c("subject", "sex", "sample", "nationality", "group", "timepoint", "timepoint.within.group", "bmi_group", "m3.Y")) %>%
  group_by(variable) %>%
  mutate(value = scale(value, center = FALSE)) %>%  # put all taxa on same scale
  ungroup() %>%
  mutate(variable2 = factor(gsub("\\.", " ", variable),
                            levels = gsub("\\.", " ", proj$rowname))) # arrange genera by ordination

# plot a heatmap
ggplot(B1, aes(x = variable2, y = sample,
               fill = value)) +
  geom_tile() +
  scico::scale_fill_scico(palette = "bilbao", name = "Abundance (z)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
        axis.text.y = element_text(size = 6, colour = B1$nationality)) +
  xlab("Sample") +
  ylab("Genera")



```






```{r}

D <- dist(A)
m2 <- cmdscale(D, k = 2)
B2 <- as.data.frame(cbind(d, m2))

ggplot(B2, aes(x = `1`, y = `2`, shape = nationality, colour = `Prevotella melaninogenica et rel.`)) +
  geom_point(size = 4) +
  scico::scale_colour_scico(palette = "vik") +
  theme_minimal()

```




In `r fig_nums('fig_3')`, *samples* are sorted along a single dimension using non-metric multi-dimensional scaling (NMDS) (on Bray-Curtis distances; see `help(neatsort)` for available methods in the `microbiome` R package), then plotted as a heatmap of abundances. This shows some distinct clusters of *Prevotella melaninogenica*, *Bacteroides vulgatus*, and *Oscillospira guillermondii*. However, no comparison between groups can be easily made from this.  

```{r}
p <- plot_composition(microbiome::transform(pseq2, "compositional"),
                    plot.type = "heatmap",
                    otu_sort = "neatmap",
                    sample.sort = "neatmap") +
  scico::scale_fill_scico(palette = "bilbao", name = "") +
  theme(text = element_text(size = 8),
        axis.text.x = element_text(size = 6, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 5))
print(p)
```
